---
description: Interface & Contract conventions — defining contracts between components
alwaysApply: false
---

# Interface & Contract Conventions

## Structure
- Interface classes live in `app/Contracts/`
- Interfaces define a **contract** — the shape a class must conform to, without dictating the implementation

## Naming
- Use a clear noun or adjective that describes the capability: `PaymentGateway`, `Notifiable`, `ReportGenerator`
- Avoid `Interface` suffix — the namespace and context make it clear: `app/Contracts/PaymentGateway`

## When to Use an Interface
- When you have (or anticipate) multiple implementations of the same concept: `StripeGateway`, `PaypalGateway` both implementing `PaymentGateway`
- When you want to decouple dependent classes from concrete implementations, making them testable with fakes or mocks
- When defining an integration point that a third party or package might implement

## When NOT to Use an Interface
- When there is only ever one implementation and no realistic chance of another → the abstraction adds no value
- For every class by default → only add interfaces where they provide real decoupling

## Writing an Interface
Define only the public contract — no implementation, no properties:

```php
namespace App\Contracts;

use App\Models\Order;
use App\Data\PaymentResult;

interface PaymentGateway
{
    public function charge(Order $order, int $amountInCents): PaymentResult;

    public function refund(string $transactionId, int $amountInCents): PaymentResult;
}
```

## Writing Implementations
Each implementation fulfils the contract independently:

```php
namespace App\Services\Payment;

use App\Contracts\PaymentGateway;
use App\Data\PaymentResult;
use App\Models\Order;

class StripeGateway implements PaymentGateway
{
    public function charge(Order $order, int $amountInCents): PaymentResult
    {
        // Stripe-specific implementation
    }

    public function refund(string $transactionId, int $amountInCents): PaymentResult
    {
        // Stripe-specific implementation
    }
}
```

## Binding in the Service Container
Bind the interface to a concrete implementation in a service provider. Swap implementations by changing a single binding:

```php
// AppServiceProvider
use App\Contracts\PaymentGateway;
use App\Services\Payment\StripeGateway;

public function register(): void
{
    $this->app->bind(PaymentGateway::class, StripeGateway::class);
}
```

## Consuming an Interface
Always type-hint the interface, never the concrete class — this keeps the consumer decoupled from the implementation:

```php
// Action
class ChargePaymentMethod
{
    public function __construct(
        private readonly PaymentGateway $gateway,
    ) {}

    public function execute(Order $order, int $amountInCents): PaymentResult
    {
        return $this->gateway->charge($order, $amountInCents);
    }
}
```

## Testing with Interfaces
Interfaces make faking trivial — swap the binding in tests without touching production code:

```php
// In a test
$this->app->bind(PaymentGateway::class, FakePaymentGateway::class);
```

## What Belongs in an Interface
- The public method signatures that define the contract
- Return type declarations
- PHPDoc blocks explaining intent where the signature alone is insufficient

## What Does NOT Belong in an Interface
- Default implementations → use an abstract class if defaults are needed
- Constants specific to one implementation → keep in the concrete class
- Business logic → **Actions** or **Services**
