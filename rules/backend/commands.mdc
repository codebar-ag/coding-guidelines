---
description: Command conventions — command classes, how to use them, and what belongs in them
globs: app/Console/Commands/**/*.php
alwaysApply: false
---

# Command Conventions

## Structure
- Command classes live in `app/Console/Commands/`
- Each command should have a single, clearly defined responsibility
- Complex logic belongs in **Actions** or **Services**, not in the command itself — commands are the entry point only

## Naming
- Use descriptive, verb-noun names that reflect the action: `SendInvoiceReminders`, `ImportProductCsv`, `PruneExpiredSessions`
- Command signatures should follow the `namespace:action` pattern: `invoices:send-reminders`, `products:import`

## Arguments & Options
- Every argument and option **must** have a clear description
- Validate all input using the `Validator` class — never trust raw input
- Use `--option` flags for optional behaviour; avoid positional ambiguity

```php
protected $signature = 'invoices:send-reminders
                        {email : The email address to send the reminder to}
                        {--dry-run : Simulate the command without persisting any changes}';

public function handle(): int
{
    $validated = validator(
        [
            'email' => $this->argument('email'),
            'dry_run' => $this->option('dry-run'),
        ],
        [
            'email'   => ['required', 'email'],
            'dry_run' => ['boolean'],
        ]
    )->validate();

    // use $validated['email'] and $validated['dry_run'] from here on
}
```


## Error Handling
Implement `PromptsForMissingInput` so users receive clear prompts instead of silent failures:
```php
use Symfony\Component\Console\Command\Command;
use Illuminate\Contracts\Console\PromptsForMissingInput;

class NotifyUser extends Command implements PromptsForMissingInput
{
    // ...
}
```

## Return Values
Commands must **always** return either `self::SUCCESS` or `self::FAILURE` — never `void` or `null`:
```php
public function handle(): int
{
    return self::SUCCESS;
    return self::FAILURE;
}
```

## What Does NOT Belong in a Command
- Business logic → move to **Actions** or **Services**

## Example: Well-Structured Command
```php
class SendInvoiceReminders extends Command implements PromptsForMissingInput
{
    protected $signature = 'invoices:send-reminders {email : The email address to send the reminder to}';
    protected $description = 'Send invoice payment reminders to a specific user.';

    public function __construct(private readonly SendInvoiceReminderAction $action)
    {
        parent::__construct();
    }

    public function handle(): int
    {
        $validated = validator(['email' => $this->argument('email')], [
            'email' => ['required', 'email'],
        ])->validate();

        try {
            $this->action->execute($validated['email']);
            $this->info("Reminder sent to {$validated['email']}.");
            return self::SUCCESS;
        } catch (Throwable $e) {
            $this->error("Failed: {$e->getMessage()}");
            return self::FAILURE;
        }
    }
}
```