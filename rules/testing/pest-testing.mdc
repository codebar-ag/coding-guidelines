---
description: Pest PHP testing conventions — unit, feature, browser, and architecture tests
globs: tests/**/*.php
alwaysApply: false
---

# Pest Testing Conventions

## Structure
```
tests/
├── Feature/        # HTTP, database, and integration tests
├── Unit/           # Pure logic — no framework dependencies
├── Browser/        # Full browser flows via Laravel Dusk
└── Architecture/   # Convention enforcement via arch()
```

Generate tests via Artisan:
```bash
php artisan make:test --pest FeatureName Test
```

## Naming
- Test files mirror the class they test: `UserController` → `UserControllerTest.php`
- Test descriptions read as plain English sentences: `it('creates an invoice for the given order')`
- Group related tests with `describe()` named after the class or feature under test

## Non-Negotiable Rules
- Always use **Pest syntax** — never raw PHPUnit classes or `$this->assert*` outside of HTTP responses
- Always follow **AAA**: Arrange → Act → Assert, with a comment for each section
- Always use **named HTTP assertion methods** — never `assertStatus(int)` with a raw integer
- Never delete a test without explicit approval

---

## Test Anatomy

### Basic Test — AAA Pattern
Every test follows Arrange → Act → Assert. Always label each section with a comment:
```php
it('creates an invoice for the given order', function () {
    // Arrange
    $order = Order::factory()->create();

    // Act
    $response = $this->postJson('/api/invoices', ['order_id' => $order->id]);

    // Assert
    $response->assertCreated();
    expect(Invoice::count())->toBe(1);
});
```

### Grouping with `describe()`
Use `describe()` to group tests by controller, feature, or concept — improves output readability and makes `beforeEach` scope clear:
```php
describe('InvoiceController', function () {
    it('lists all invoices', function () { ... });
    it('creates an invoice', function () { ... });
    it('deletes a draft invoice', function () { ... });
});
```

### Shared Setup with `beforeEach()`
Use `beforeEach()` inside a `describe()` block to set up shared state. Never repeat setup across tests:
```php
describe('InvoiceController', function () {
    beforeEach(function () {
        $this->user = User::factory()->create();
        $this->actingAs($this->user);
    });

    it('creates an invoice', function () {
        $this->postJson('/api/invoices', ['order_id' => 1])
            ->assertCreated();
    });
});
```

### Database Reset
Add `uses(RefreshDatabase::class)` at the top of every test file that touches the database:
```php
uses(RefreshDatabase::class);

it('stores an invoice record', function () {
    // DB is freshly migrated for every test in this file
});
```

---

## HTTP Assertions
Always use named assertion methods — never `assertStatus()` with a raw integer:

| Use | Never | Status |
|-----|-------|--------|
| `assertSuccessful()` | `assertStatus(200)` | 2xx |
| `assertCreated()` | `assertStatus(201)` | 201 |
| `assertNoContent()` | `assertStatus(204)` | 204 |
| `assertUnprocessable()` | `assertStatus(422)` | 422 |
| `assertForbidden()` | `assertStatus(403)` | 403 |
| `assertUnauthorized()` | `assertStatus(401)` | 401 |
| `assertNotFound()` | `assertStatus(404)` | 404 |

---

## `expect()` Assertions
Use `expect()` for all non-HTTP assertions. Chain properties for concise, readable assertions:
```php
expect($invoice)
    ->status->toBe(InvoiceStatus::Draft)
    ->total->toBe(10000)
    ->user_id->toBe($this->user->id);

expect($collection)
    ->toHaveCount(3)
    ->each->toBeInstanceOf(Invoice::class);
```

---

## Datasets
Use datasets instead of duplicating tests for multiple inputs, validation rules, or edge cases:
```php
it('rejects invalid email addresses', function (string $email) {
    $this->postJson('/api/users', ['email' => $email])
        ->assertUnprocessable();
})->with([
    'empty string'     => [''],
    'missing @'        => ['notanemail'],
    'missing tld'      => ['user@domain'],
    'whitespace'       => ['user @domain.com'],
]);
```

---

## Mocking
For events, mail, notifications, and queues, always prefer **Laravel fakes** over mocks — they are simpler, more readable, and less brittle:
```php
// ✓ Prefer Laravel fakes
Event::fake();
Mail::fake();
Notification::fake();
Queue::fake();

// ✓ Use mock() only when you need to assert method calls on a class
use function Pest\Laravel\mock;

it('sends a welcome email on registration', function () {
    // Arrange
    mock(WelcomeMailer::class)
        ->shouldReceive('send')
        ->once();

    // Act
    $this->postJson('/api/users', User::factory()->make()->toArray());

    // Assert — enforced by mock expectation above
});
```

Always import `mock` before use:
```php
use function Pest\Laravel\mock;
```

---

## Browser Tests
Browser tests live in `tests/Browser/` and use Laravel Dusk. See `dusk.md` for full conventions. Key rules that always apply:

- Always use `DatabaseTruncation` — never `RefreshDatabase` in browser tests
- Always call `assertNoJavaScriptErrors()` after every `visit()`
- Always use `dusk=""` HTML attributes as selectors — never CSS classes or IDs
- Never use `pause()` — use `waitFor()`, `waitForText()`, or `waitUntilMissing()` instead
```php
uses(DatabaseTruncation::class);

it('user can submit an invoice', function () {
    // Arrange
    $user = User::factory()->create();

    // Act + Assert
    $this->browse(function (Browser $browser) use ($user) {
        $browser->loginAs($user)
                ->visit('/invoices/create')
                ->assertNoJavaScriptErrors()
                ->type('@amount-input', '100')
                ->press('@submit-button')
                ->waitForText('Invoice created')
                ->assertSee('Invoice created');
    });
});
```

---

## Architecture Tests
Enforce structural conventions automatically. Lives in `tests/Architecture/`. Add a test for every convention defined in the coding guidelines:
```php
// Naming conventions
arch('controllers have the correct suffix')
    ->expect('App\Http\Controllers')
    ->toHaveSuffix('Controller');

arch('models extend Eloquent')
    ->expect('App\Models')
    ->toExtend(Model::class);

arch('actions have the correct suffix')
    ->expect('App\Actions')
    ->toHaveSuffix('');

// Layer isolation — services must not depend on the HTTP layer
arch('services do not use HTTP requests')
    ->expect('App\Services')
    ->not->toUse(['Illuminate\Http\Request']);

// No debug statements left in production code
arch('no debug calls in production code')
    ->expect('App')
    ->not->toUse(['dd', 'dump', 'var_dump', 'ray', 'ddd']);
```

---

## Running Tests
```bash
# Run all tests
php artisan test --compact

# Run a single file
php artisan test --compact tests/Feature/InvoiceTest.php

# Run by test name
php artisan test --compact --filter=creates_an_invoice

# Re-run only failures
php artisan dusk:fails  # browser tests only
```

---

## What Belongs in Each Layer

| Layer | Test Type | Uses DB | Uses Browser |
|---|---|---|---|
| `Unit/` | Pure class and method logic | No | No |
| `Feature/` | HTTP endpoints, DB interactions | Yes | No |
| `Browser/` | Full user flows with JavaScript | Yes | Yes |
| `Architecture/` | Convention enforcement | No | No |

## Common Pitfalls

| Mistake | Fix |
|---|---|
| `assertStatus(200)` | Use `assertSuccessful()` |
| `RefreshDatabase` in browser tests | Use `DatabaseTruncation` |
| `pause(3000)` in browser tests | Use `waitFor()` or `waitForText()` |
| Repeating tests for different inputs | Use datasets |
| CSS class selectors in Dusk | Use `dusk=""` attributes |
| Missing `uses(RefreshDatabase::class)` | Add to every feature/unit file touching the DB |
| Missing `assertNoJavaScriptErrors()` | Chain after every `visit()` in browser tests |
| Deleting a test | Never — get explicit approval first |