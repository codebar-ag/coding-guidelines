---
description: Service conventions — complex orchestration across multiple domains
alwaysApply: false
---

# Service Conventions

## Structure
- Service classes live in `app/Services/`
- A service **orchestrates** multiple actions, external APIs, or domain operations into a cohesive workflow

## Naming
- Name after the domain or integration they serve: `PaymentService`, `SubscriptionService`, `StripeService`
- Avoid generic suffixes like `Manager` or `Handler`

## When to Use a Service
- Coordinating multiple actions across different domains in a specific order
- Wrapping a third-party API or SDK behind an application-owned interface
- Providing a consistent interface for an external system (payment gateways, email providers, SMS)

## When NOT to Use a Service
- A single discrete operation → use an **Action**
- Reusable utility logic → use a **Helper**
- Simple model interactions → keep in the **Controller** or **Action**

## Writing a Service
Services may expose multiple related methods, all scoped to their domain. Inject dependencies via the constructor:

```php
namespace App\Services;

use App\Actions\CreateInvoice;
use App\Actions\ChargePaymentMethod;
use App\Actions\SendPaymentConfirmation;
use App\Models\Order;
use App\Models\Payment;
use Illuminate\Support\Facades\DB;

class PaymentService
{
    public function __construct(
        private readonly CreateInvoice           $createInvoice,
        private readonly ChargePaymentMethod     $chargePaymentMethod,
        private readonly SendPaymentConfirmation $sendConfirmation,
    ) {}

    public function processOrderPayment(Order $order): Payment
    {
        return DB::transaction(function () use ($order) {
            $invoice = $this->createInvoice->execute($order);
            $payment = $this->chargePaymentMethod->execute($order, $invoice);
            $this->sendConfirmation->execute($payment);

            return $payment;
        });
    }

    public function refund(Payment $payment): void
    {
        // refund orchestration logic
    }
}
```

## What Belongs in a Service
- Orchestration of multiple actions in a defined order
- Transaction boundaries (`DB::transaction`) that span multiple operations
- Third-party API communication behind a clean internal interface
- Error handling and retry logic for external systems

## What Does NOT Belong in a Service
- HTTP concerns (request, response) → **Controller**
- Individual business operations → **Action**
- Model attribute logic → **Model** (accessors, mutators, scopes)
- Authorization → **Policy**

## Usage
Services are resolved via the service container and injected into controllers, commands, or jobs:

```php
// Controller
class PaymentController extends Controller
{
    public function store(StorePaymentRequest $request, PaymentService $service): JsonResponse
    {
        $order = Order::findOrFail($request->validated('order_id'));

        $payment = $service->processOrderPayment($order);

        return new JsonResponse(new PaymentResource($payment), 201);
    }
}
```

## Registering External Service Wrappers
If a service wraps a third-party SDK, bind it in a service provider to keep configuration out of the class itself:

```php
// AppServiceProvider
$this->app->singleton(StripeService::class, function () {
    return new StripeService(config('services.stripe.secret'));
});
```
