---
description: Event & Listener conventions — decoupled communication between application layers
alwaysApply: false
---

# Event & Listener Conventions

## Structure
- Event classes live in `app/Events/`
- Listener classes live in `app/Listeners/`
- Events and listeners decouple the **source of something that happened** from **the reactions to it**

## Naming
- Events: past-tense noun phrase describing what happened → `InvoicePaid`, `UserRegistered`, `OrderShipped`
- Listeners: verb phrase describing the reaction → `SendInvoicePaidNotification`, `CreateWelcomeTask`, `UpdateInventory`

## When to Use Events & Listeners
- When one action should trigger multiple independent side effects
- When you want to decouple the source of a change from its consequences
- When side effects should optionally be queued or handled asynchronously

## When NOT to Use Events & Listeners
- Simple, single side effects → trigger directly inside the **Action**
- When the side effect must complete synchronously and inline → call it directly
- When the flow needs to be easy to trace linearly → events can obscure control flow

## Writing an Event
Events are simple data containers — they hold the data needed by listeners and nothing else:

```php
namespace App\Events;

use App\Models\Invoice;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class InvoicePaid
{
    use Dispatchable, SerializesModels;

    public function __construct(
        public readonly Invoice $invoice,
    ) {}
}
```

## Writing a Listener
Each listener handles one specific reaction. Implement `ShouldQueue` for side effects that can be deferred:

```php
namespace App\Listeners;

use App\Events\InvoicePaid;
use App\Notifications\InvoicePaidNotification;
use Illuminate\Contracts\Queue\ShouldQueue;

class SendInvoicePaidNotification implements ShouldQueue
{
    public function handle(InvoicePaid $event): void
    {
        $event->invoice->user->notify(new InvoicePaidNotification($event->invoice));
    }

    public function failed(InvoicePaid $event, \Throwable $exception): void
    {
        // Handle failure — log, alert, retry logic
    }
}
```

## Registering Events & Listeners
Register in `EventServiceProvider`. One event may have multiple listeners:

```php
protected $listen = [
    InvoicePaid::class => [
        SendInvoicePaidNotification::class,
        UpdateAccountingRecords::class,
        NotifyAccountManager::class,
    ],
];
```

## Dispatching an Event
Dispatch from an **Action** after the operation completes — never from a controller or model:

```php
// Inside an Action
class MarkInvoiceAsPaid
{
    public function execute(Invoice $invoice): void
    {
        $invoice->update(['paid_at' => now()]);

        InvoicePaid::dispatch($invoice);
    }
}
```

## What Belongs in an Event
- The data (models, scalars) needed by listeners to do their work
- No logic — events are plain data objects

## What Belongs in a Listener
- One specific reaction to the event
- Optional queue configuration (`ShouldQueue`, `$queue`, `$delay`)
- A `failed()` method when queued, to handle job failures gracefully

## What Does NOT Belong in Events or Listeners
- Business logic → **Actions** or **Services**
- Chained side effects that must happen in order → **Service** with explicit calls
- Authorization → **Policies**
