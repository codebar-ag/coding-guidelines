---
description: Trait conventions — when to use traits, how to write them, and what belongs in them
globs: app/Traits/**/*.php
alwaysApply: false
---

# Trait Conventions

## Structure
- Trait classes live in `app/Traits/`
- Each trait should have a **single, clearly defined responsibility**
- Traits are for **shared behaviour** across multiple unrelated classes — not a dumping ground for miscellaneous logic

## Naming
- Use descriptive names that reflect the behaviour they provide, not the classes that use them
- Suffix with `able` when the trait grants a capability: `Archivable`, `Taggable`, `Sluggable`
- Or use a noun phrase when it groups related accessors/scopes: `HasTimestamps`, `HasAddress`

## When to Use a Trait
Use a trait when the **same behaviour is needed across multiple unrelated classes** and extracting it into a base class or service is not appropriate:

- Shared model scopes, accessors, or mutators across multiple Eloquent models
- Reusable controller behaviour (e.g. handling file uploads)
- Common query logic that doesn't belong in a single repository

## When NOT to Use a Trait
- When the logic only exists in one class → keep it inline
- When the logic contains complex business rules → use an **Action** or **Service**
- When the logic depends heavily on external services → use a **Service** class
- To avoid inheritance → reconsider your architecture instead

## Writing a Trait
Keep traits focused. Each trait should do one thing and expose a minimal, clear interface:
```php
namespace App\Traits;

use Illuminate\Database\Eloquent\Builder;

trait Archivable
{
    public function archive(): void
    {
        $this->update(['archived_at' => now()]);
    }

    public function unarchive(): void
    {
        $this->update(['archived_at' => null]);
    }

    public function isArchived(): bool
    {
        return !is_null($this->archived_at);
    }

    public function scopeArchived(Builder $query): Builder
    {
        return $query->whereNotNull('archived_at');
    }

    public function scopeNotArchived(Builder $query): Builder
    {
        return $query->whereNull('archived_at');
    }
}
```
```php
// Usage
class Post extends Model
{
    use Archivable;
}

$post->archive();
Post::archived()->get();
```

## Eloquent Model Traits
When writing traits for Eloquent models, use `bootTraitName()` to hook into the model lifecycle without overriding `boot()` in the model itself:
```php
trait Sluggable
{
    public static function bootSluggable(): void
    {
        static::creating(function ($model) {
            $model->slug = str($model->name)->slug();
        });
    }

    public function scopeBySlug(Builder $query, string $slug): Builder
    {
        return $query->where('slug', $slug);
    }
}
```

## Initializing Trait Properties
Use `initializeTraitName()` to set default property values on instantiation, keeping model constructors clean:
```php
trait HasDefaultStatus
{
    public function initializeHasDefaultStatus(): void
    {
        $this->attributes['status'] ??= 'draft';
    }
}
```

## What Belongs in a Trait
- Shared Eloquent scopes, accessors, and mutators
- Shared lifecycle hooks via `bootTraitName()`
- Small, stateless helper methods directly tied to the class using the trait
- Interface implementation shared across multiple models

## What Does NOT Belong in a Trait
- Business logic → **Actions** or **Services**
- Complex multi-step processes → **Actions**
- Anything with external dependencies (APIs, queues) → **Services**
- Logic only used in one place → keep it in the class itself

## Example: Full Model Trait
```php
namespace App\Traits;

use Illuminate\Database\Eloquent\Builder;

trait HasAddress
{
    public function getFullAddressAttribute(): string
    {
        return "{$this->street}, {$this->city}, {$this->postal_code}";
    }

    public function scopeInCity(Builder $query, string $city): Builder
    {
        return $query->where('city', $city);
    }

    public function scopeInPostalCode(Builder $query, string $postalCode): Builder
    {
        return $query->where('postal_code', $postalCode);
    }
}
```
```php
// Used across unrelated models
class User extends Model
{
    use HasAddress;
}

class Supplier extends Model
{
    use HasAddress;
}

// Consistent interface across both
$user->full_address;
User::inCity('Basel')->get();
Supplier::inCity('Basel')->get();
```