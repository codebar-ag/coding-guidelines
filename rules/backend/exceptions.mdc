---
description: Exception conventions — custom exceptions for domain and application errors
alwaysApply: false
---

# Exception Conventions

## Structure
- Exception classes live in `app/Exceptions/`
- Custom exceptions represent **named, meaningful failure states** in your domain — not generic error wrappers

## Naming
- Use a clear noun phrase describing what went wrong: `InvoiceAlreadyPaid`, `InsufficientFunds`, `PaymentGatewayUnavailable`
- Always suffix with `Exception`: `InvoiceAlreadyPaidException`, `InsufficientFundsException`

## When to Use a Custom Exception
- A failure state that is specific to your domain and needs to be caught and handled differently from generic exceptions
- When you want to communicate a precise failure reason to the caller without relying on error codes or magic strings
- When an exception needs to carry domain-specific data (e.g. the model that caused the failure)

## When NOT to Use a Custom Exception
- Generic errors already covered by PHP or Laravel built-ins (`InvalidArgumentException`, `ModelNotFoundException`)
- When a simple early return or validation rule handles the case cleanly

## Writing an Exception
Keep exceptions focused. Use named constructors (`static` factory methods) to make throw sites readable:

```php
namespace App\Exceptions;

use App\Models\Invoice;
use RuntimeException;

class InvoiceAlreadyPaidException extends RuntimeException
{
    public function __construct(
        public readonly Invoice $invoice,
    ) {
        parent::__construct(
            "Invoice #{$invoice->id} has already been paid and cannot be modified."
        );
    }

    public static function for(Invoice $invoice): static
    {
        return new static($invoice);
    }
}
```

## Throwing an Exception
Throw at the point of failure inside an **Action** or **Service**, using the named constructor for readability:

```php
class MarkInvoiceAsPaid
{
    public function execute(Invoice $invoice): void
    {
        if ($invoice->isPaid()) {
            throw InvoiceAlreadyPaidException::for($invoice);
        }

        $invoice->update(['paid_at' => now()]);
    }
}
```

## Handling Exceptions
Register exception rendering and reporting in `bootstrap/app.php` using `withExceptions()`:

```php
->withExceptions(function (Exceptions $exceptions) {

    // Convert domain exceptions to HTTP responses
    $exceptions->render(function (InvoiceAlreadyPaidException $e, Request $request) {
        return response()->json([
            'message' => $e->getMessage(),
        ], 422);
    });

    // Suppress reporting for expected domain exceptions
    $exceptions->dontReport([
        InvoiceAlreadyPaidException::class,
    ]);
})
```

## Renderable Exceptions
For exceptions that always map to the same HTTP response, implement `Renderable` directly on the exception instead of registering a handler:

```php
use Illuminate\Http\Request;

class InvoiceAlreadyPaidException extends RuntimeException implements \Illuminate\Contracts\Support\Renderable
{
    public function render(Request $request): \Illuminate\Http\JsonResponse
    {
        return response()->json(['message' => $this->getMessage()], 422);
    }
}
```

## What Belongs in an Exception
- A clear, human-readable message set via `parent::__construct()`
- Domain-specific context data as public readonly properties
- Named static constructors to make throw sites expressive
- `render()` when the exception always maps to the same HTTP response

## What Does NOT Belong in an Exception
- Business logic → **Actions** or **Services**
- Complex recovery logic → handle in the caller or a dedicated handler
- Silent swallowing of errors → always log or report unexpected exceptions
